# Exercise 1

1. Dockerfile<br>
a) Мы планинуем собрать JS приложение, и у нас есть 'package.json' помимо исходного когда приложения. Поэтому я предполагаю в качестве базового образа Docker использовать node, а не nginx. Например я возьму последнюю версию официального node образа. 
Возможно просто установить node в образ с nginx, но мне кажется это не самая хорошая идея, например по соображениям безопасности. Если мы не хотим использовать веб-сервер node для ответов на запросы к нашему приложению, то мне кажтся логичным вынести ingress как отдельный сервис. Кроме того, философия докера: "один процесс - один контейнер". Я знаю что сейчас это правило имеет множество исключению (например sidecar паттерн), но для этого конкретного случая я предпочитаю использовать разные контейнеры для ingress и нашего приложения. Поэтому я изменил образ в директиве 'FROM' и просто удалил 'RUN apt-get update && apt-get install -y nodejs' из предоставленного Dockerfile (кстати в этой строчке еще была опечатка 'upddate').<br>
b) Далее, я раскоментировал строку 'WORKDIR /app'. Возможно это необязательный шаг, но хранить код приложения и зависимые файлы в отдельной папке лучше и прозрачнее. Как минимум это может уменьшить вероятность ошибок, например, с путями к нашему приложению.<br>
c) Я добавил 'RUN npm install' для установки зависимостей нашего приложения.<br>
d) Исправил директиву CMD ('CMD ["node", "index.js"]') на "обычную" (не shell) потому что у нас нет переменных окружения в выражении CMD или еще что то со сложным/динамическим синтаксисом. На этом с Dockerfile вроде бы все. Но если мы попытаемся собрать его, мы обнаружим следующую проблему. Так что переходим к пункту 2.<br>

2. package.json<br>
a) Если мы попытаемся собрать наше приложение (даже не используя докер, а просто на хосте с node запустив 'npm install') мы получим следующую ошибку: 'http^0.0.1 dependency'. Я использовал поиск и выяснил что пакет с именем 'http' это не http сервер (https://www.npmjs.com/package/http), так что я думаю, что очевидно что нам нужен пакет 'http-server' (https://www.npmjs.com/package/http-server) вместо http. На текущий момент последняя версия 'http-server' это '14.1.1'. Т. к. это тестовое задание я буду использовать самую свежую доступную версию 'http-server' (итоговый package.json лежит в этом репо: Ex1/part1/package.json).
Теперь образ с нашим приложением должен собираться корректно.<br>

3. index.js<br>
a) Да, я проверил, он действительно собирается корректно. Но когда я смотрю как приложение работает в моем браузере, я вижу нечитаемый текст. Мы используем русский язык в выводе приложения, так я думаю что очевидно, в первую очередь "грешить" на кодировку. Я снова использовал поиск с запросом "how to set charset for node http-server" (честно говоря, я не слишком близко знаком с JS и node), но решение нашлось легко, добавление 'charset=utf-8' в свойства 'Content-Type'в методе res.writeHead помогло. После пересборки приложения я вижу в браузере читаемую надпись на русском языке:<br>
![image](https://github.com/Slonskiy/slotegrator-test/assets/101737363/75a307dd-8ea6-4c36-b714-f92fb39b8d92)

4. Ingress<br>
Так как я решил не использовать nginx и node с кодом нашего приложения в одном контейнере, давайте решим типичную задачу развертывания ingress.<br>
Я сделаю это двумя путями - с использованием только обычного консольного docker и с использованием docker-compose.<br>
a) Docker engine.<br>
Очевидно нам нужен nginx (возможно использовать, например, haproxy  или любой другой аналогичный продукт) :) Давайте возьмем nginx:latest.<br>
Я взял очень простой конфиг для nginx (он более чем обычный, так что я не думаю что в этом месте нужны комментарии):<br>
```
events { worker_connections 1024; }

http {
    server {
        listen 80;

        location / {
            proxy_pass http://slotegrator:3000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```
Так как nginx будет использоваться только в качестве ingress-сервиса, то я предполагаю что мы не хотим что бы к нашему приложению можно было обратиться напрямую "снаружи". Для этого мы создадим в докере виртуальную сеть, и подключим к ней контейнер с нашим приложением и ingress сервис:<br>
`sudo docker network create app-network`<br>
После этого попробуем запустить контейнер с нашим приложением и наш ingress (я не буду пересобирать образ с нашим приложением, потому что он у меня уже есть и с первой части задания изменений в нем не было:<br>
`sudo docker run -d --rm --name slotegrator --network app-network slotegrator/app`<br>
`sudo docker run -d --name nginx-ingress --network app-network -p 80:80 -v $(pwd)/nginx.conf:/etc/nginx/nginx.conf:ro nginx:latest`<br>
Все должно быть хорошо, но нет - ingress завершается с ошибкой 'host not found in upstream "slotegrator"'.<br>
После небольшого времени проведенного в поиске, я понял что nginx в официальном образе с dockerhub пытается получить адресс используя оба IP (IPv6 and IPv4) протокола. Это описано на stack overflow и частично [тут](https://nginx.org/en/docs/http/ngx_http_core_module.html#resolver). Как становиться понятно из результатов поиска, docker не имеет ipv6 (или из коробки он не активен), тогда как nginx пытается получить адресс или сначала по IPv6, или обязательно по обоим протоколам. Поэтому я просто добавил следующую строчку в секцию http моего nginx config: 'resolver 127.0.0.11 ipv6=off;'. И это работает.<br>
Теперь я могу видеть тот же результат что и в первой части, но уже на 80-м порту на localhost, т. к. nginx слушает на хост машине 80-й порт и потом проксирует запрос на наше приложение.<br>
b) Docker-compose<br>
А теперь давайте сделаем тоже самое что предыдушей подчасти, но используя docker-compose.<br>
На самом деле, все что нам нужно это то что у нас уже есть (корректные Dockerfile, package.json, index.js и nginx.conf), установленный docker-compose и docker-compose.yml.<br>
Я написал простой docker-compose.yml для нашего случая:<br>
```
version: '3'

services:
  slotegrator:
    build:
      context: ./app
      dockerfile: Dockerfile
    networks:
      - app-network
  
  nginx-ingress:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    networks:
      - app-network
    depends_on:
      - slotegrator

networks:
  app-network:
    driver: bridge
```
В этом случае я подразумеваю что структура файлов будет как в моем репозитарии: Dockerfile и исходники приложения в подпапке app и nginx.conf должен быть уровнем выше, там же где и docker-compose.yml.<br>
После запуска, как можно видеть на моем скрине приложение работает:
![image](https://github.com/Slonskiy/slotegrator-test/assets/101737363/23afe334-3db9-41a1-a255-a5058b059984)

Заключение:<br>
В-первой части этого упражение я выбрал использование другого базового образа Docker для нашего приложения и исправил несколько проблем с приложением и его контейнеризацией (я раскоментировал директиву 'WORKDIR', добавил шаг 'RUN npm install' и исправил директиву 'CMD' в Dockerfile. Так же я изменил зависимость для http сервера в package.json и исправил кодировку в исходнике приложения) и проверил работоспособность контейнеризированного приложения.<br>
Во-второй части я добавил ingress сервис (на nginx как отдельный контейнер), создал виртуальную сеть в докере, присоединил оба контейнера к ней и исправил проблему с разрешением адресов доменных имен в nginx для нашего случая.
Ну и наконец, я использовал docker-compose для сокращения ручного труда при деплое этого приложения.
Я не пробовал добавить образ и контейнер с certbot или использовать полученные другим образом ssl сертификаты, потому что у меня нет полноценного доменного имени и результат может быть непрозрачным. Но, конечно, добавить ssl для http возможно и это не самая сложная задача.

 # Exercise 2



